<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Healthcare Booking — SSOT MVP (Single File)</title>
  <!-- TailwindCSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React 18 UMD -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel Standalone (to compile JSX in-browser for this demo) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    html, body { height: 100%; }
  </style>
</head>
<body class="min-h-screen bg-slate-50 text-slate-800">
  <div id="root"></div>

  <script type="text/babel" data-presets="env,react">
    const { useEffect, useMemo, useReducer, useRef, useState } = React;

    /*********************************
     * Mock Data & Utilities
     *********************************/
    const DOCTORS = [
      { id: "d1", name: "Dra. Ana López", specialty: "Clínica Médica" },
      { id: "d2", name: "Dr. Martín Pérez", specialty: "Dermatología" },
      { id: "d3", name: "Dra. Sofía García", specialty: "Cardiología" },
    ];

    // Fixed time slots
    const SLOT_TIMES = ["09:00", "09:30", "10:00", "10:30", "11:00", "14:00", "14:30", "15:00", "15:30", "16:00"];

    function yyyyMmDd(date = new Date()) {
      const d = new Date(date);
      const mm = String(d.getMonth() + 1).padStart(2, "0");
      const dd = String(d.getDate()).padStart(2, "0");
      return `${d.getFullYear()}-${mm}-${dd}`;
    }

    function toIsoLocal(dateStr, timeStr) {
      const [y, m, d] = dateStr.split("-").map(Number);
      const [hh, mm] = timeStr.split(":").map(Number);
      const dt = new Date(y, m - 1, d, hh, mm, 0, 0);
      return dt.toISOString();
    }

    function formatDateTime(iso) {
      const d = new Date(iso);
      return d.toLocaleString(undefined, {
        weekday: "short",
        year: "numeric",
        month: "short",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
      });
    }

    function addHours(iso, hours) {
      const d = new Date(iso);
      d.setHours(d.getHours() + hours);
      return d.toISOString();
    }

    // Simple non-crypto hash for audit chaining
    function simpleHash(str) {
      let hash = 5381;
      for (let i = 0; i < str.length; i++) hash = (hash * 33) ^ str.charCodeAt(i);
      return (hash >>> 0).toString(16);
    }

    function uid(prefix = "id") {
      return `${prefix}_${Math.random().toString(36).slice(2, 10)}`;
    }

    /*********************************
     * State
     *********************************/
    const initial = {
      patients: [],
      appointments: [],
      waitlist: [],
      locks: [], // {doctorId, iso, lockedUntil}
      preventedDuplicates: 0,
      audit: [], // {id, ts, action, payload, prevHash, hash}
    };

    function loadState() {
      try { const raw = localStorage.getItem("ssot_mvp_state"); return raw ? JSON.parse(raw) : initial; }
      catch { return initial; }
    }

    function saveState(state) { localStorage.setItem("ssot_mvp_state", JSON.stringify(state)); }

    function appendAudit(state, action, payload) {
      const prevHash = state.audit.length ? state.audit[state.audit.length - 1].hash : "genesis";
      const entry = { id: uid("audit"), ts: new Date().toISOString(), action, payload, prevHash, hash: simpleHash(prevHash + action + JSON.stringify(payload) + Math.random()) };
      return [...state.audit, entry];
    }

    function upsertPatient(arr, p) {
      const i = arr.findIndex(x => x.dni === p.dni);
      if (i === -1) return [...arr, p];
      const merged = { ...arr[i], ...p };
      return [...arr.slice(0, i), merged, ...arr.slice(i + 1)];
    }

    function doctorName(id) { return DOCTORS.find(d => d.id === id)?.name || "Unknown"; }
    function doctorSpec(id) { return DOCTORS.find(d => d.id === id)?.specialty || ""; }

    /*********************************
     * Domain Rules
     *********************************/
    function isSlotTaken(state, doctorId, iso) {
      return state.appointments.some(a => a.doctorId === doctorId && a.iso === iso && a.status !== "cancelled");
    }
    function isSlotLocked(state, doctorId, iso) {
      const now = Date.now();
      return state.locks.some(l => l.doctorId === doctorId && l.iso === iso && l.lockedUntil > now);
    }
    function hasRecentBooking(state, dni, iso, windowHours = 72) {
      const target = new Date(iso).getTime();
      const lo = target - windowHours * 3600 * 1000;
      const hi = target + windowHours * 3600 * 1000;
      return state.appointments.some(a => a.patient?.dni === dni && a.status !== "cancelled" && new Date(a.iso).getTime() >= lo && new Date(a.iso).getTime() <= hi);
    }

    /*********************************
     * Reducer
     *********************************/
    function reducer(state, ev) {
      switch (ev.type) {
        case "RESET": {
          const s = { ...initial };
          s.audit = appendAudit({ audit: [] }, "RESET", {});
          saveState(s); return s;
        }
        case "LOAD": { return loadState(); }
        case "CREATE_APPT": {
          const appt = ev.appt;
          const next = {
            ...state,
            patients: upsertPatient(state.patients, appt.patient),
            appointments: [...state.appointments, appt],
            audit: appendAudit(state, "CREATE_APPT", { id: appt.id, doctorId: appt.doctorId, iso: appt.iso, src: appt.source })
          };
          saveState(next); return next;
        }
        case "PREVENTED_DUP": {
          const next = { ...state, preventedDuplicates: state.preventedDuplicates + 1, audit: appendAudit(state, "PREVENTED_DUP", ev.details) };
          saveState(next); return next;
        }
        case "CONFIRM": {
          const { id } = ev;
          const appointments = state.appointments.map(a => a.id === id ? { ...a, status: "confirmed", updatedAt: new Date().toISOString() } : a);
          const next = { ...state, appointments, audit: appendAudit(state, "CONFIRM", { id }) };
          saveState(next); return next;
        }
        case "CANCEL": {
          const { id, reason } = ev;
          const target = state.appointments.find(a => a.id === id);
          let appointments = state.appointments.map(a => a.id === id ? { ...a, status: "cancelled", updatedAt: new Date().toISOString() } : a);
          if (target) {
            const match = state.waitlist.find(w => w.doctorId === target.doctorId && w.iso === target.iso);
            if (match) {
              const newAppt = {
                id: uid("appt"), doctorId: match.doctorId, doctorName: doctorName(match.doctorId), specialty: doctorSpec(match.doctorId),
                iso: match.iso, source: "waitlist", status: "booked", createdAt: new Date().toISOString(), updatedAt: new Date().toISOString(),
                patient: match.patient,
              };
              appointments = [...appointments, newAppt];
            }
          }
          const waitlist = state.waitlist.filter(w => !(target && w.doctorId === target.doctorId && w.iso === target.iso));
          const next = { ...state, appointments, waitlist, audit: appendAudit(state, "CANCEL", { id, reason }) };
          saveState(next); return next;
        }
        case "NO_SHOW": {
          const { id } = ev;
          const appointments = state.appointments.map(a => a.id === id ? { ...a, status: "no-show", updatedAt: new Date().toISOString() } : a);
          const next = { ...state, appointments, audit: appendAudit(state, "NO_SHOW", { id }) };
          saveState(next); return next;
        }
        case "ADD_WAITLIST": {
          const w = ev.item;
          const next = { ...state, waitlist: [...state.waitlist, w], audit: appendAudit(state, "ADD_WAITLIST", { doctorId: w.doctorId, iso: w.iso, dni: w.patient?.dni }) };
          saveState(next); return next;
        }
        case "REMOVE_LOCKS_EXPIRED": {
          const now = Date.now();
          const locks = state.locks.filter(l => l.lockedUntil > now);
          if (locks.length !== state.locks.length) {
            const next = { ...state, locks, audit: appendAudit(state, "CLEAN_LOCKS", { removed: state.locks.length - locks.length }) };
            saveState(next); return next;
          }
          return state;
        }
        case "LOCK_SLOT": {
          const { doctorId, iso, ms = 120000 } = ev;
          const lockedUntil = Date.now() + ms;
          const lock = { doctorId, iso, lockedUntil };
          const others = state.locks.filter(l => !(l.doctorId === doctorId && l.iso === iso));
          const next = { ...state, locks: [...others, lock], audit: appendAudit(state, "LOCK_SLOT", { doctorId, iso, until: new Date(lockedUntil).toISOString() }) };
          saveState(next); return next;
        }
        case "IMPORT_JSON": {
          const next = { ...state, ...ev.payload };
          saveState(next); return next;
        }
        default: return state;
      }
    }

    /*********************************
     * Components
     *********************************/
    function App() {
      const [state, dispatch] = useReducer(reducer, initial);
      const [tab, setTab] = useState("patient");
      useEffect(() => { dispatch({ type: "LOAD" }); }, []);
      useEffect(() => { const t = setInterval(() => dispatch({ type: "REMOVE_LOCKS_EXPIRED" }), 5000); return () => clearInterval(t); }, []);

      return (
        <div className="min-h-screen">
          <header className="sticky top-0 z-10 bg-white border-b border-slate-200">
            <div className="max-w-6xl mx-auto px-4 py-4 flex items-center justify-between">
              <h1 className="text-2xl font-bold">Healthcare Booking — SSOT MVP</h1>
              <nav className="flex gap-2">
                {[
                  { id: "patient", label: "Patient Booking" },
                  { id: "wa", label: "WhatsApp Intake (sim)" },
                  { id: "staff", label: "Staff Console" },
                  { id: "metrics", label: "Metrics & Audit" },
                  { id: "admin", label: "Admin" },
                ].map((t) => (
                  <button key={t.id} onClick={() => setTab(t.id)} className={`px-3 py-1.5 rounded-full text-sm border ${tab===t.id?"bg-slate-900 text-white border-slate-900":"bg-white hover:bg-slate-100"}`}>
                    {t.label}
                  </button>
                ))}
              </nav>
            </div>
          </header>

          <main className="max-w-6xl mx-auto px-4 py-6">
            {tab === "patient" && <PatientBooking state={state} dispatch={dispatch} />}
            {tab === "wa" && <WhatsAppIntake state={state} dispatch={dispatch} />}
            {tab === "staff" && <StaffConsole state={state} dispatch={dispatch} />}
            {tab === "metrics" && <MetricsAudit state={state} />}
            {tab === "admin" && <AdminTools state={state} dispatch={dispatch} />}
          </main>

          <footer className="max-w-6xl mx-auto px-4 py-8 text-xs text-slate-500">
            <p>Demo: all data is stored locally in your browser (localStorage). Refreshing preserves data; use Admin → Reset to clear.</p>
          </footer>
        </div>
      );
    }

    function PatientBooking({ state, dispatch }) {
      const [doctorId, setDoctorId] = useState(DOCTORS[0].id);
      const [date, setDate] = useState(yyyyMmDd());
      const [slot, setSlot] = useState("");
      const [name, setName] = useState("");
      const [dni, setDni] = useState("");
      const [phone, setPhone] = useState("");
      const [error, setError] = useState("");
      const [ok, setOk] = useState("");

      const slots = useMemo(() => generateSlots(doctorId, date, state), [doctorId, date, state.appointments, state.locks]);

      function handleLock(iso) {
        if (isSlotLocked(state, doctorId, iso)) { setError("This slot is temporarily locked by another user. Try another one."); return; }
        dispatch({ type: "LOCK_SLOT", doctorId, iso, ms: 120000 });
        setSlot(iso); setError("");
      }

      function submit() {
        setOk(""); setError("");
        if (!slot || !name || !dni || !phone) { setError("Please complete all fields."); return; }
        if (isSlotTaken(state, doctorId, slot)) { setError("This slot is already booked."); return; }
        if (hasRecentBooking(state, dni, slot, 72)) {
          dispatch({ type: "PREVENTED_DUP", details: { dni, slot } });
          setError("Duplicate booking detected: same patient has an appointment within ±72h. Please reschedule.");
          return;
        }
        const appt = {
          id: uid("appt"), doctorId, doctorName: doctorName(doctorId), specialty: doctorSpec(doctorId),
          iso: slot, source: "web", status: "booked",
          createdAt: new Date().toISOString(), updatedAt: new Date().toISOString(),
          patient: { name, dni, phone },
        };
        dispatch({ type: "CREATE_APPT", appt });
        setOk("Appointment created. You will receive reminders at T-24h and T-2h.");
        setSlot(""); setName(""); setDni(""); setPhone("");
      }

      function joinWaitlist() {
        if (!slot || !name || !dni || !phone) { setError("Please complete all fields."); return; }
        const item = { id: uid("wl"), doctorId, iso: slot, createdAt: new Date().toISOString(), patient: { name, dni, phone } };
        dispatch({ type: "ADD_WAITLIST", item });
        setOk("Added to waitlist for this slot. We will auto-assign if it frees up.");
        setSlot(""); setName(""); setDni(""); setPhone("");
      }

      return (
        <section className="grid md:grid-cols-2 gap-6">
          <div className="bg-white rounded-2xl shadow p-5">
            <h2 className="text-lg font-semibold mb-4">Book an appointment</h2>
            <div className="grid grid-cols-1 gap-3">
              <label className="text-sm">Doctor / Specialty
                <select value={doctorId} onChange={e=>setDoctorId(e.target.value)} className="mt-1 w-full border rounded-lg p-2">
                  {DOCTORS.map(d=> <option key={d.id} value={d.id}>{d.name} — {d.specialty}</option>)}
                </select>
              </label>
              <label className="text-sm">Date
                <input type="date" value={date} onChange={e=>setDate(e.target.value)} className="mt-1 w-full border rounded-lg p-2" />
              </label>

              <div>
                <p className="text-sm mb-2">Available time slots</p>
                <div className="grid grid-cols-3 md:grid-cols-4 gap-2">
                  {slots.map(s => (
                    <button
                      key={s.iso}
                      disabled={s.taken || s.locked}
                      onClick={() => handleLock(s.iso)}
                      className={`px-3 py-2 rounded-lg border text-sm ${slot===s.iso?"bg-slate-900 text-white border-slate-900":""} ${s.taken?"bg-slate-200 text-slate-400 cursor-not-allowed":""} ${s.locked?"bg-amber-50 border-amber-300 text-amber-700 cursor-not-allowed":" bg-white hover:bg-slate-50"}`}
                      title={s.locked?"Temporarily locked by another user":""}
                    >{new Date(s.iso).toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"})}</button>
                  ))}
                </div>
                <p className="text-xs text-slate-500 mt-1">Selecting a slot places a short lock (2 min) to prevent collisions while you complete the form.</p>
              </div>

              <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
                <label className="text-sm">Full name
                  <input value={name} onChange={e=>setName(e.target.value)} className="mt-1 w-full border rounded-lg p-2" placeholder="Jane Doe" />
                </label>
                <label className="text-sm">DNI
                  <input value={dni} onChange={e=>setDni(e.target.value)} className="mt-1 w-full border rounded-lg p-2" placeholder="12345678" />
                </label>
                <label className="text-sm">Phone
                  <input value={phone} onChange={e=>setPhone(e.target.value)} className="mt-1 w-full border rounded-lg p-2" placeholder="11-0000-0000" />
                </label>
              </div>

              {error && <p className="text-sm text-red-600">{error}</p>}
              {ok && <p className="text-sm text-green-700">{ok}</p>}

              <div className="flex gap-3 mt-2">
                <button onClick={submit} className="px-4 py-2 rounded-xl bg-slate-900 text-white">Confirm booking</button>
                <button onClick={joinWaitlist} className="px-4 py-2 rounded-xl border">Join waitlist</button>
              </div>
            </div>
          </div>

          <div className="bg-white rounded-2xl shadow p-5">
            <h2 className="text-lg font-semibold mb-4">Upcoming appointments (your selection)</h2>
            <ApptList state={state} doctorId={doctorId} date={date} />
          </div>
        </section>
      );
    }

    function generateSlots(doctorId, dateStr, state) {
      const slots = SLOT_TIMES.map(t => ({ iso: toIsoLocal(dateStr, t) }));
      return slots.map(s => ({ ...s, taken: isSlotTaken(state, doctorId, s.iso), locked: isSlotLocked(state, doctorId, s.iso) }));
    }

    function ApptList({ state, doctorId, date }) {
      const items = state.appointments
        .filter(a => a.doctorId === doctorId && yyyyMmDd(a.iso) === date && a.status !== "cancelled")
        .sort((a,b) => new Date(a.iso) - new Date(b.iso));
      if (!items.length) return <p className="text-sm text-slate-500">No appointments yet for this date.</p>;
      return (
        <ul className="divide-y">
          {items.map(a => (
            <li key={a.id} className="py-3 flex items-start justify-between gap-4">
              <div>
                <p className="font-medium">{formatDateTime(a.iso)}</p>
                <p className="text-sm text-slate-600">{a.patient.name} — DNI {a.patient.dni} — {a.source}</p>
              </div>
              <span className={`text-xs px-2 py-1 rounded-full ${a.status==="confirmed"?"bg-green-100 text-green-700":a.status==="booked"?"bg-amber-100 text-amber-700":a.status==="no-show"?"bg-rose-100 text-rose-700":"bg-slate-200 text-slate-600"}`}>{a.status}</span>
            </li>
          ))}
        </ul>
      );
    }

    function WhatsAppIntake({ state, dispatch }) {
      const [msg, setMsg] = useState("");
      const [feedback, setFeedback] = useState("");

      function parseAndCreate() {
        setFeedback("");
        try {
          const found = DOCTORS.find(d => msg.toLowerCase().includes(d.name.split(" ")[1].toLowerCase())) || DOCTORS[0];
          const dtMatch = msg.match(/(\d{4}-\d{2}-\d{2})\s(\d{2}:\d{2})/);
          const dniMatch = msg.match(/dni\s*(\d+)/i);
          const telMatch = msg.match(/tel\s*([\d\-\+\s]+)/i);
          const nameMatch = msg.match(/name\s*([A-Za-zÁÉÍÓÚÑáéíóúñ\s]+)/i);

          if (!dtMatch || !dniMatch || !telMatch) throw new Error("Could not parse date/time, DNI or phone. Try: 'Book Dr. López on 2025-09-01 15:00 for DNI 12345678, Tel 11-2222'. Optional: 'Name Juan Pérez'.");

          const iso = toIsoLocal(dtMatch[1], dtMatch[2]);
          const doctorId = found.id;
          const patient = { name: nameMatch?nameMatch[1].trim():"WhatsApp User", dni: dniMatch[1], phone: telMatch[1].trim() };

          if (isSlotTaken(state, doctorId, iso)) throw new Error("Slot already booked.");
          if (hasRecentBooking(state, patient.dni, iso, 72)) {
            dispatch({ type: "PREVENTED_DUP", details: { dni: patient.dni, slot: iso } });
            throw new Error("Duplicate booking detected for this patient within ±72h.");
          }
          const appt = {
            id: uid("appt"), doctorId, doctorName: doctorName(doctorId), specialty: doctorSpec(doctorId),
            iso, source: "whatsapp", status: "booked", createdAt: new Date().toISOString(), updatedAt: new Date().toISOString(),
            patient,
          };
          dispatch({ type: "CREATE_APPT", appt });
          setFeedback(`OK ✅ Created: ${found.name} — ${formatDateTime(iso)} — DNI ${patient.dni}`);
          setMsg("");
        } catch (e) {
          setFeedback(`❌ ${e.message}`);
        }
      }

      return (
        <section className="grid md:grid-cols-2 gap-6">
          <div className="bg-white rounded-2xl shadow p-5">
            <h2 className="text-lg font-semibold mb-3">Simulated WhatsApp → Structured Booking</h2>
            <p className="text-sm text-slate-600 mb-3">Type a free-text message. The system parses date/time, DNI, phone, and doctor’s surname, then creates the booking in the SAME database.</p>
            <textarea value={msg} onChange={e=>setMsg(e.target.value)} className="w-full h-32 border rounded-xl p-3" placeholder="Book Dr. López on 2025-09-01 15:00 for DNI 12345678, Tel 11-2222, Name Juan Pérez" />
            <div className="flex gap-3 mt-3">
              <button onClick={parseAndCreate} className="px-4 py-2 rounded-xl bg-slate-900 text-white">Parse & Create</button>
              <button onClick={()=>setMsg("Book Dr. López on "+yyyyMmDd(new Date())+" 15:00 for DNI 12345678, Tel 11-2222, Name Juan Pérez")} className="px-4 py-2 rounded-xl border">Example</button>
            </div>
            {feedback && <p className="mt-3 text-sm">{feedback}</p>}
          </div>

          <div className="bg-white rounded-2xl shadow p-5">
            <h2 className="text-lg font-semibold mb-3">Today’s Bookings</h2>
            <ApptTable state={state} />
          </div>
        </section>
      );
    }

    function ApptTable({ state, filterFn }) {
      const items = (state.appointments || [])
        .filter(a => a.status !== "cancelled")
        .filter(a => filterFn ? filterFn(a) : true)
        .sort((a,b) => new Date(a.iso) - new Date(b.iso));
      if (!items.length) return <p className="text-sm text-slate-500">No appointments to show.</p>;
      return (
        <div className="overflow-x-auto">
          <table className="min-w-full text-sm">
            <thead>
              <tr className="bg-slate-100 text-left">
                <th className="p-2">When</th>
                <th className="p-2">Doctor</th>
                <th className="p-2">Patient</th>
                <th className="p-2">DNI</th>
                <th className="p-2">Phone</th>
                <th className="p-2">Source</th>
                <th className="p-2">Status</th>
              </tr>
            </thead>
            <tbody>
              {items.map(a => (
                <tr key={a.id} className="border-b">
                  <td className="p-2 whitespace-nowrap">{formatDateTime(a.iso)}</td>
                  <td className="p-2">{a.doctorName}</td>
                  <td className="p-2">{a.patient.name}</td>
                  <td className="p-2">{a.patient.dni}</td>
                  <td className="p-2">{a.patient.phone}</td>
                  <td className="p-2">{a.source}</td>
                  <td className="p-2">
                    <span className={`text-xs px-2 py-1 rounded-full ${a.status==="confirmed"?"bg-green-100 text-green-700":a.status==="booked"?"bg-amber-100 text-amber-700":a.status==="no-show"?"bg-rose-100 text-rose-700":"bg-slate-200 text-slate-600"}`}>{a.status}</span>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      );
    }

    function StaffConsole({ state, dispatch }) {
      const [doctorFilter, setDoctorFilter] = useState("all");
      const [onlyUpcoming, setOnlyUpcoming] = useState(true);

      const filtered = useMemo(() => {
        const now = new Date();
        return state.appointments
          .filter(a => a.status !== "cancelled")
          .filter(a => (doctorFilter==="all"?true:a.doctorId===doctorFilter))
          .filter(a => onlyUpcoming ? new Date(a.iso) >= now : true)
          .sort((a,b) => new Date(a.iso) - new Date(b.iso));
      }, [state.appointments, doctorFilter, onlyUpcoming]);

      function sendReminders(hoursBefore) {
        const now = new Date();
        const from = addHours(now.toISOString(), hoursBefore - 0.6);
        const to = addHours(now.toISOString(), hoursBefore + 0.6);
        const target = state.appointments.filter(a => a.status === "booked" && new Date(a.iso) >= new Date(from) && new Date(a.iso) <= new Date(to));
        alert(`Would send ${target.length} reminders (T-${hoursBefore}h). Use actions per row to Confirm/Reschedule/Cancel.`);
      }

      return (
        <section className="space-y-4">
          <div className="bg-white rounded-2xl shadow p-5 flex flex-wrap gap-3 items-center justify-between">
            <div className="flex flex-wrap gap-3 items-center">
              <label className="text-sm">Doctor
                <select value={doctorFilter} onChange={e=>setDoctorFilter(e.target.value)} className="ml-2 border rounded-lg p-2">
                  <option value="all">All</option>
                  {DOCTORS.map(d=> <option key={d.id} value={d.id}>{d.name}</option>)}
                </select>
              </label>
              <label className="text-sm inline-flex items-center gap-2">
                <input type="checkbox" checked={onlyUpcoming} onChange={e=>setOnlyUpcoming(e.target.checked)} /> Only upcoming
              </label>
            </div>
            <div className="flex gap-2">
              <button onClick={()=>sendReminders(24)} className="px-3 py-2 rounded-xl border">Send T-24h reminders</button>
              <button onClick={()=>sendReminders(2)} className="px-3 py-2 rounded-xl border">Send T-2h reminders</button>
            </div>
          </div>

          <div className="bg-white rounded-2xl shadow">
            <div className="p-5 border-b flex items-center justify-between">
              <h3 className="font-semibold">Appointments</h3>
              <span className="text-xs text-slate-500">Actions: Confirm / Cancel / Mark no-show</span>
            </div>
            <div className="p-5 overflow-x-auto">
              <table className="min-w-full text-sm">
                <thead>
                  <tr className="bg-slate-100 text-left">
                    <th className="p-2">When</th><th className="p-2">Doctor</th><th className="p-2">Patient</th><th className="p-2">DNI</th><th className="p-2">Source</th><th className="p-2">Status</th><th className="p-2">Actions</th>
                  </tr>
                </thead>
                <tbody>
                  {filtered.map(a => (
                    <tr key={a.id} className="border-b">
                      <td className="p-2 whitespace-nowrap">{formatDateTime(a.iso)}</td>
                      <td className="p-2">{a.doctorName}</td>
                      <td className="p-2">{a.patient.name}</td>
                      <td className="p-2">{a.patient.dni}</td>
                      <td className="p-2">{a.source}</td>
                      <td className="p-2">
                        <span className={`text-xs px-2 py-1 rounded-full ${a.status==="confirmed"?"bg-green-100 text-green-700":a.status==="booked"?"bg-amber-100 text-amber-700":a.status==="no-show"?"bg-rose-100 text-rose-700":"bg-slate-200 text-slate-600"}`}>{a.status}</span>
                      </td>
                      <td className="p-2">
                        <div className="flex gap-2">
                          <button onClick={()=>dispatch({ type: "CONFIRM", id: a.id })} className="px-2 py-1 rounded-lg border">Confirm</button>
                          <button onClick={()=>dispatch({ type: "CANCEL", id: a.id, reason: "patient" })} className="px-2 py-1 rounded-lg border">Cancel</button>
                          <button onClick={()=>dispatch({ type: "NO_SHOW", id: a.id })} className="px-2 py-1 rounded-lg border">No-show</button>
                        </div>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>

          <div className="grid md:grid-cols-2 gap-6">
            <div className="bg-white rounded-2xl shadow p-5">
              <h3 className="font-semibold mb-2">Waitlist</h3>
              <Waitlist state={state} />
            </div>
            <div className="bg-white rounded-2xl shadow p-5">
              <h3 className="font-semibold mb-2">Locks (anti-collision)</h3>
              <Locks state={state} />
            </div>
          </div>
        </section>
      );
    }

    function Waitlist({ state }) {
      if (!state.waitlist.length) return <p className="text-sm text-slate-500">Empty.</p>;
      return (
        <ul className="divide-y text-sm">
          {state.waitlist.map(w => (
            <li key={w.id} className="py-2 flex items-center justify-between">
              <div>
                <p>{formatDateTime(w.iso)} — {doctorName(w.doctorId)}</p>
                <p className="text-slate-600">{w.patient.name} — DNI {w.patient.dni}</p>
              </div>
              <span className="text-xs text-slate-500">pending</span>
            </li>
          ))}
        </ul>
      );
    }

    function Locks({ state }) {
      const now = Date.now();
      const locks = state.locks.filter(l => l.lockedUntil > now).sort((a,b) => a.lockedUntil - b.lockedUntil);
      if (!locks.length) return <p className="text-sm text-slate-500">No active locks.</p>;
      return (
        <ul className="divide-y text-sm">
          {locks.map(l => (
            <li key={`${l.doctorId}-${l.iso}`} className="py-2 flex items-center justify-between">
              <div>
                <p>{formatDateTime(l.iso)} — {doctorName(l.doctorId)}</p>
                <p className="text-slate-600">Lock until {new Date(l.lockedUntil).toLocaleTimeString()}</p>
              </div>
            </li>
          ))}
        </ul>
      );
    }

    function MetricsAudit({ state }) {
      const now = new Date();
      const past30 = state.appointments.filter(a => new Date(a.iso) < now);
      const upcoming = state.appointments.filter(a => new Date(a.iso) >= now && a.status !== "cancelled");
      const noShows = past30.filter(a => a.status === "no-show").length;
      const done = past30.filter(a => a.status === "confirmed").length;
      const nsRate = (noShows + done) ? (noShows / (noShows + done)) * 100 : 0;

      return (
        <section className="grid lg:grid-cols-2 gap-6">
          <div className="bg-white rounded-2xl shadow p-5">
            <h3 className="font-semibold mb-3">KPIs</h3>
            <div className="grid grid-cols-2 md:grid-cols-3 gap-4 text-center">
              <Kpi label="Appointments (upcoming)" value={upcoming.length} />
              <Kpi label="Appointments (past)" value={past30.length} />
              <Kpi label="No-show rate (past)" value={`${nsRate.toFixed(1)}%`} />
              <Kpi label="Waitlist size" value={state.waitlist.length} />
              <Kpi label="Duplicates prevented" value={state.preventedDuplicates} />
              <Kpi label="Active locks" value={state.locks.filter(l => l.lockedUntil > Date.now()).length} />
            </div>
          </div>

          <div className="bg-white rounded-2xl shadow p-5">
            <h3 className="font-semibold mb-3">Audit log (hash-chained)</h3>
            {state.audit.length === 0 ? (
              <p className="text-sm text-slate-500">No audit entries yet.</p>
            ) : (
              <div className="max-h-96 overflow-auto text-xs">
                <table className="min-w-full">
                  <thead className="bg-slate-100 text-left">
                    <tr>
                      <th className="p-2">Time</th>
                      <th className="p-2">Action</th>
                      <th className="p-2">Prev Hash</th>
                      <th className="p-2">Hash</th>
                    </tr>
                  </thead>
                  <tbody>
                    {state.audit.slice().reverse().map(e => (
                      <tr key={e.id} className="border-b">
                        <td className="p-2 whitespace-nowrap">{new Date(e.ts).toLocaleString()}</td>
                        <td className="p-2">{e.action}</td>
                        <td className="p-2 font-mono text-[10px] text-slate-500">{e.prevHash}</td>
                        <td className="p-2 font-mono text-[10px]">{e.hash}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}
          </div>
        </section>
      );
    }

    function Kpi({ label, value }) {
      return (
        <div className="rounded-2xl border p-4">
          <div className="text-2xl font-bold">{value}</div>
          <div className="text-xs text-slate-500">{label}</div>
        </div>
      );
    }

    function AdminTools({ state, dispatch }) {
      const fileRef = useRef(null);
      const json = JSON.stringify(state, null, 2);
      return (
        <section className="grid md:grid-cols-2 gap-6">
          <div className="bg-white rounded-2xl shadow p-5">
            <h3 className="font-semibold mb-3">Export / Import</h3>
            <textarea readOnly className="w-full h-48 border rounded-xl p-3 font-mono text-xs" value={json} />
            <div className="flex gap-2 mt-3">
              <button onClick={() => navigator.clipboard && navigator.clipboard.writeText(json)} className="px-3 py-2 rounded-xl border">Copy JSON</button>
              <label className="px-3 py-2 rounded-xl border cursor-pointer">
                Import JSON
                <input ref={fileRef} type="file" accept="application/json" className="hidden" onChange={(e)=>{
                  const f = e.target.files?.[0]; if (!f) return;
                  const reader = new FileReader();
                  reader.onload = () => { try { const data = JSON.parse(String(reader.result)); dispatch({ type: "IMPORT_JSON", payload: data }); } catch(e){ alert("Invalid JSON"); } };
                  reader.readAsText(f);
                }} />
              </label>
            </div>
          </div>

          <div className="bg-white rounded-2xl shadow p-5">
            <h3 className="font-semibold mb-3">Danger Zone</h3>
            <p className="text-sm text-slate-600 mb-3">Reset local data (appointments, waitlist, audit, locks).</p>
            <button onClick={()=>dispatch({ type: "RESET" })} className="px-4 py-2 rounded-xl bg-rose-600 text-white">Reset All</button>
          </div>
        </section>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>